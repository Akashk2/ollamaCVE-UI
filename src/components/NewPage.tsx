// import React, { useContext, useEffect, useRef, useState } from 'react';
import { ChatService } from '../service/ChatService';
import { ChatMessage, MessageType, Role } from '../models/ChatCompletion';
import { UserContext } from '../UserContext';
import { NotificationService } from '../service/NotificationService';
// import '../rag/ChatInterface.css';
import ReactDOM from 'react-dom/client';
import chatSettingsDB, { chatSettingsEmitter, updateShowInSidebar } from '../service/ChatSettingsDB';
import ChatSettingDropdownMenu from "./ChatSettingDropdownMenu";
import { UPLOAD_COMPLETIONS_ENDPOINT, RAG_SOLUTION_COMPLETIONS_ENDPOINT } from "../constants/apiEndpoints";
import { PaperClipIcon, StopCircleIcon } from "@heroicons/react/24/outline";
import { useLocation, useNavigate, useParams } from "react-router-dom";
import { useTranslation } from 'react-i18next';
import { SubmitButton } from "./SubmitButton";
import ConversationService, { Conversation } from '../service/ConversationService';
import CustomChatSplash from './CustomChatSplash';
import Chat from "./Chat";
import { OpenAIModel } from '../models/model';
import { ChatSettings } from '../models/ChatSettings';
import { ArrowUturnDownIcon } from '@heroicons/react/24/outline';
import {
  DEFAULT_MODEL,
  CONVERSATION_NOT_FOUND
} from "../constants/appConstants";
// MessageBox.tsx
import React, {
  useContext,
  ChangeEvent,
  FormEvent,
  forwardRef,
  KeyboardEvent,
  useCallback,
  useImperativeHandle,
  useRef,
  useState,
  useEffect
} from 'react';
import {
  IMAGE_MIME_TYPES,
  MAX_IMAGE_ATTACHMENTS_PER_MESSAGE,
  MAX_ROWS,
  SNIPPET_MARKERS,
  TEXT_MIME_TYPES
} from '../constants/appConstants';
import Tooltip from "./Tooltip";
import FileDataPreview from './FileDataPreview';
import { FileDataRef } from '../models/FileData';
import { preprocessImage } from '../utils/ImageUtils';
export interface MessageBoxHandles {
  clearInputValue: () => void;
  getTextValue: () => string;
  reset: () => void;
  resizeTextArea: () => void;
  focusTextarea: () => void;
  pasteText: (text: string) => void;
}

interface MessageBoxProps {
  className: string;
  callApp: Function;
  loading: boolean;
  setLoading: (loading: boolean) => void;
  allowImageAttachment: string;
}
const defaultCallApp = () => {};
const NewPageInterface = forwardRef<MessageBoxHandles, MessageBoxProps>(
  ({ className, loading, setLoading, callApp = defaultCallApp, allowImageAttachment }, ref) => {
    const textValue = useRef('');
    const [model, setModel] = useState<OpenAIModel | null>(null);
    const [isTextEmpty, setIsTextEmpty] = useState(true);
    const resizeTimeoutRef = useRef<number | null>(null);
    const [fileDataRef, setFileDataRef] = useState<FileDataRef[]>([]);
    const [messages, setMessages] = useState<ChatMessage[]>([]);
    const { t } = useTranslation();
    const location = useLocation();
    const navigate = useNavigate();
    const messageBoxRef = useRef<MessageBoxHandles>(null);
    const [conversation, setConversation] = useState<Conversation | null>(null);
    const [query, setQuery] = useState('');
    const { id, gid } = useParams<{ id?: string, gid?: string }>();
    const [responses, setResponses] = useState<ChatMessage[]>([]);
    const [file, setFile] = useState<File | null>(null);
    const textAreaRef = useRef<HTMLTextAreaElement>(null);
    const buttonRef = useRef<HTMLButtonElement | null>(null);
    const [showScrollButton, setShowScrollButton] = useState(false);
    const [chatSettings, setChatSettings] = useState<ChatSettings | undefined>(undefined);
    const [allowAutoScroll, setAllowAutoScroll] = useState(true);
    const chatSettingsRef = useRef(chatSettings);
    const uploadFile = async (file: File) => {
      const formData = new FormData();
      formData.append('file', file);
      console.log('Uploading file:', file);
      let endpoint = UPLOAD_COMPLETIONS_ENDPOINT;

      try {
        const response = await fetch(endpoint, {
          method: 'POST',
          body: formData,
        });

        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(`File upload failed: ${response.status} ${errorText}`);
        }

        // Read the response as text since it's not JSON
        const resultText = await response.text();
        console.log('File upload response:', resultText); // This will log "File uploaded!"

        // If needed, you can wrap it in an object for consistency
        const result = { message: resultText };

        // Proceed with further processing if necessary
        // For example, you could update your state or UI based on the upload
      } catch (error) {
        if (error instanceof Error && error.name === 'AbortError') {
          console.log('Stream aborted.');
        } else if (error instanceof Error) {
          NotificationService.handleUnexpectedError(error, 'Error reading response.');
        } else {
          console.error('An unexpected error occurred');
        }
        console.error('Upload error:', error);
      }
    };



    const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
      const selectedFile = e.target.files?.[0];
      setFile(selectedFile || null);
      if (selectedFile) {
        uploadFile(selectedFile);
      }
    };

    // const handleQuerySubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    //   e.preventDefault();
    //   if (query.trim()) {
    //     addMessage(Role.User, MessageType.Normal, query);
    //     setQuery('');
    //     let endpoint = RAG_SOLUTION_COMPLETIONS_ENDPOINT
    //     try {
    //       const response = await fetch(endpoint, {
    //         method: 'POST',
    //         headers: {
    //           'Content-Type': 'application/json',
    //         },
    //         body: JSON.stringify({ question: query }),
    //       });
    //       if (!response.ok) throw new Error('Query submission failed');
    //       const result = await response.json();
    //       addMessage(Role.Assistant, MessageType.Normal, result.answer || 'No answer available');
    //     } catch (error) {
    //       if (error instanceof Error && error.name === 'AbortError') {
    //         console.log('Stream aborted.');
    //       } else if (error instanceof Error) {
    //         NotificationService.handleUnexpectedError(error, 'Error reading response.');
    //       } else {
    //         console.error('An unexpected error occurred');
    //       }
    //     }
    //   }
    // };

    // const handleQuerySubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    //   e.preventDefault();
    //   if (query.trim()) {
    //     addMessage(Role.User, MessageType.Normal, query);
    //     setQuery('');
    //     let endpoint = RAG_SOLUTION_COMPLETIONS_ENDPOINT;
    //     try {
    //       const response = await fetch(endpoint, {
    //         method: 'POST',
    //         headers: {
    //           'Content-Type': 'application/json',
    //         },
    //         body: JSON.stringify({ question: query }),
    //       });
    //       if (!response.ok) throw new Error('Query submission failed');

    //       const result = await response.json();

    //       // Use the textResponse field from the result
    //       addMessage(Role.Assistant, MessageType.Normal, result.textResponse || 'No answer available');

    //     } catch (error) {
    //       if (error instanceof Error && error.name === 'AbortError') {
    //         console.log('Stream aborted.');
    //       } else if (error instanceof Error) {
    //         NotificationService.handleUnexpectedError(error, 'Error reading response.');
    //       } else {
    //         console.error('An unexpected error occurred');
    //       }
    //     }
    //   }
    // };

    const handleQuerySubmit = async (e: React.FormEvent<HTMLFormElement>) => {
      e.preventDefault();

      // Check if a file is selected
      if (!file) {
        NotificationService.handleUnexpectedError(new Error("Please upload a file."), 'File upload required'); // Use your notification system
        return;
      }

      if (query.trim()) {
        addMessage(Role.User, MessageType.Normal, query);
        setQuery('');
        let endpoint = RAG_SOLUTION_COMPLETIONS_ENDPOINT;
        try {
          const response = await fetch(endpoint, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ question: query }),
          });
          if (!response.ok) throw new Error('Query submission failed');

          const result = await response.json();
          addMessage(Role.Assistant, MessageType.Normal, result.textResponse || 'No answer available');
        } catch (error) {
          if (error instanceof Error && error.name === 'AbortError') {
            console.log('Stream aborted.');
          } else if (error instanceof Error) {
            NotificationService.handleUnexpectedError(error, 'Error reading response.');
          } else {
            console.error('An unexpected error occurred');
          }
        }
      }
    };


    const addMessage = (role: Role, messageType: MessageType, content: string) => {
      const newMessage: ChatMessage = {
        id: responses.length + 1,
        role,
        messageType,
        content,
        fileDataRef: [],
      };
      setResponses((prevMessages) => [...prevMessages, newMessage]);
    };

    const setTextValue = (value: string) => {
      textValue.current = value;
    }

    const setTextAreaValue = (value: string) => {
      if (textAreaRef.current) {
        textAreaRef.current.value = value;
      }
      setIsTextEmpty(textAreaRef.current?.value.trim() === '');
      debouncedResize();
    }

    useImperativeHandle(ref, () => ({
      // Method to clear the textarea
      clearInputValue: () => {
        clearValueAndUndoHistory(textAreaRef);
      },
      getTextValue: () => {
        return textValue.current;
      },
      reset: () => {
        clearValueAndUndoHistory(textAreaRef);
        setTextValue('');
        setTextAreaValue('');
        setFileDataRef([]);
      },
      resizeTextArea: () => {
        if (textAreaRef.current) {
          textAreaRef.current.style.height = 'auto';
        }
      },
      focusTextarea: () => {
        if (textAreaRef.current) {
          textAreaRef.current.focus();
        }
      },
      pasteText: (text: string) => {
        insertTextAtCursorPosition(text);
      },
    }));

    // Function to handle auto-resizing of the textarea
    const handleAutoResize = useCallback(() => {
      if (textAreaRef.current) {
        const target = textAreaRef.current;
        const maxHeight = parseInt(getComputedStyle(target).lineHeight || '0', 10) * MAX_ROWS;

        target.style.height = 'auto';
        if (target.scrollHeight <= maxHeight) {
          target.style.height = `${target.scrollHeight}px`;
        } else {
          target.style.height = `${maxHeight}px`;
        }
      }
    }, []);

    // Debounced resize function
    const debouncedResize = useCallback(() => {
      if (resizeTimeoutRef.current !== null) {
        clearTimeout(resizeTimeoutRef.current);
      }
      resizeTimeoutRef.current = window.setTimeout(() => {
        handleAutoResize();
      }, 100); // Adjust the debounce time as needed
    }, []);

    const handleTextValueUpdated = () => {
      debouncedResize();

      // After resizing, scroll the textarea to the insertion point (end of the pasted text).
      if (textAreaRef.current) {
        const textarea = textAreaRef.current;
        // Check if the pasted content goes beyond the max height (overflow scenario)
        if (textarea.scrollHeight > textarea.clientHeight) {
          // Scroll to the bottom of the textarea
          textarea.scrollTop = textarea.scrollHeight;
        }
      }
    };

    function clearValueAndUndoHistory(textAreaRef: React.RefObject<HTMLTextAreaElement>) {
      setFileDataRef([]);
      setTextValue('');
      setTextAreaValue('');
    }

    const insertTextAtCursorPosition = (textToInsert: string) => {
      if (textAreaRef.current) {
        const textArea = textAreaRef.current;
        const startPos = textArea.selectionStart || 0;
        const endPos = textArea.selectionEnd || 0;
        const text = textArea.value;
        const newTextValue =
          text.substring(0, startPos) +
          textToInsert +
          text.substring(endPos);

        // Update the state with the new value
        setTextValue(newTextValue);
        setTextAreaValue(newTextValue);

        // Move the cursor to the end of the inserted text
        const newCursorPos = startPos + textToInsert.length;
        setTimeout(() => {
          textArea.selectionStart = newCursorPos;
          textArea.selectionEnd = newCursorPos;
          // Scroll to the insertion point after the DOM update
          if (textArea.scrollHeight > textArea.clientHeight) {
            textArea.scrollTop = textArea.scrollHeight;
          }
        }, 0);
      }
    };

    const handlePaste = (event: React.ClipboardEvent<HTMLTextAreaElement>) => {

      if (event.clipboardData && event.clipboardData.items) {
        const items = event.clipboardData.items;

        for (const item of items) {
          if (item.type.indexOf("image") === 0 && allowImageAttachment !== 'no') {
            event.preventDefault();
            const file = item.getAsFile();
            if (file) {
              const reader = new FileReader();
              reader.onload = (loadEvent) => {
                if (loadEvent.target !== null) {
                  const base64Data = loadEvent.target.result;

                  if (typeof base64Data === 'string') {
                    preprocessImage(file, (base64Data, processedFile) => {
                      setFileDataRef((prevData) => [...prevData, {
                        id: 0,
                        fileData: {
                          data: base64Data,
                          type: processedFile.type,
                          source: 'pasted',
                          filename: 'pasted-image',
                        }
                      }]);
                    });
                    if (allowImageAttachment == 'warn') {
                      // todo: could warn user
                    }
                  }
                }
              };
              reader.readAsDataURL(file);
            }
          } else {

          }
        }
      }

      // Get the pasted text from the clipboard
      const pastedText = event.clipboardData.getData('text/plain');


      // Check if the pasted text contains the snippet markers
      const containsBeginMarker = pastedText.includes(SNIPPET_MARKERS.begin);
      const containsEndMarker = pastedText.includes(SNIPPET_MARKERS.end);

      // If either marker is found, just allow the default paste behavior
      if (containsBeginMarker || containsEndMarker) {
        return; // Early return if markers are present
      }

      // Count the number of newlines in the pasted text
      const newlineCount = (pastedText.match(/\n/g) || []).length;

      // Check if there are MAX_ROWS or more newlines
      if (newlineCount >= MAX_ROWS || pastedText.length > 80 * MAX_ROWS) {
        event.preventDefault();
        const modifiedText = `${SNIPPET_MARKERS.begin}\n${pastedText}\n${SNIPPET_MARKERS.end}\n`;
        insertTextAtCursorPosition(modifiedText);
      } else {
        // Allow the default paste behavior to occur
        // The textarea value will be updated automatically
      }
    };

    const checkForSpecialKey = (e: KeyboardEvent<HTMLTextAreaElement>) => {
      const isEnter = (e.key === 'Enter');

      if (isEnter) {
        if (e.shiftKey) {
          return;
        } else {
          if (!loading) {
            e.preventDefault();
            if (textAreaRef.current) {
              setTextValue(textAreaRef.current.value);
            }
            callApp(textAreaRef.current?.value || '', (allowImageAttachment === 'yes') ? fileDataRef : []);
          }
        }
      }
    };

    const handleTextChange = (event: ChangeEvent<HTMLTextAreaElement>) => {
      const newValue = event.target.value;
      setIsTextEmpty(textAreaRef.current?.value.trim() === '');
      handleTextValueUpdated();
    };

    const handleSubmit = (e: FormEvent<HTMLFormElement>) => {
      e.preventDefault();
      e.stopPropagation();
      if (textAreaRef.current) {
        setTextValue(textAreaRef.current.value);
      }
      callApp(textAreaRef.current?.value || '', (allowImageAttachment === 'yes') ? fileDataRef : []);
      if (textAreaRef.current) {
        textAreaRef.current.style.height = 'auto';
      }
    };
    const handleCancel = (event: React.MouseEvent<HTMLButtonElement>) => {
      event.preventDefault();
      event.stopPropagation();

      ChatService.cancelStream();
      setLoading(false);
    };

    const fetchAndSetChatSettings = async (gid: number) => {
      try {
        const settings = await chatSettingsDB.chatSettings.get(gid);
        setChatSettings(settings);
        if (settings) {
          if (settings.model === null) {
            setModel(null);
          } else {
            fetchModelById(settings.model).then(setModel);
          }
        }
      } catch (error) {
        console.error('Failed to fetch chat settings:', error);
      }
    };


    const chatSettingsListener = (data: { gid?: number }) => {
      const currentChatSettings = chatSettingsRef.current;
      if (data && typeof data === 'object') {
        if (currentChatSettings && currentChatSettings.id === data.gid) {
          fetchAndSetChatSettings(data.gid);
        }
      } else {
        if (currentChatSettings) {
          fetchAndSetChatSettings(currentChatSettings.id);
        }
      }
    };

    const clearInputArea = () => {
      messageBoxRef.current?.clearInputValue();
    };

    const newConversation = () => {
      setConversation(null);
      setShowScrollButton(false);
      clearInputArea();
      setMessages([]);
      messageBoxRef.current?.focusTextarea();
    }

    const handleSelectedConversation = (id: string | null) => {
      if (id && id.length > 0) {
        let n = Number(id);
        ConversationService.getConversationById(n)
          .then(conversation => {
            if (conversation) {
              setConversation(conversation);
              clearInputArea();
              ConversationService.getChatMessages(conversation).then((messages: ChatMessage[]) => {
                if (messages.length == 0) {
                  // Race condition: the navigate to /c/id and the updating of the messages state
                  // are happening at the same time.
                  console.warn('possible state problem');
                } else {
                  setMessages(messages);
                }
              }
              )
            } else {
              const errorMessage: string = 'Conversation ' + location.pathname + ' not found';
              NotificationService.handleError(errorMessage, CONVERSATION_NOT_FOUND);
              navigate('/');
            }
          });
      } else {
        newConversation();
      }
      setAllowAutoScroll(true);
      setShowScrollButton(false)
      messageBoxRef.current?.focusTextarea();
    }

    useEffect(() => {
      if (location.pathname === '/') {
        newConversation();
      } else {
        if (id) {
          handleSelectedConversation(id);
        } else {
          newConversation();
        }
      }

      if (gid) {
        const gidNumber = Number(gid);
        if (!isNaN(gidNumber)) {
          fetchAndSetChatSettings(gidNumber);
        } else {
          setChatSettings(undefined);
        }
      } else {
        setChatSettings(undefined);
      }
    }, [gid, id, location.pathname]);

    const handleSelectionChange = () => {
      const selection = window.getSelection();
      if (selection && selection.toString().trim() === '') {
        if (buttonRef.current && buttonRef.current.parentNode) {
          buttonRef.current.parentNode.removeChild(buttonRef.current);
          buttonRef.current = null;
        }
      }
    };

    useEffect(() => {
      chatSettingsEmitter.on('chatSettingsChanged', chatSettingsListener);

      const button = createButton();
      buttonRef.current = button;

      document.addEventListener('selectionchange', handleSelectionChange);

      return () => {
        document.removeEventListener('selectionchange', handleSelectionChange);
        chatSettingsEmitter.off('chatSettingsChanged', chatSettingsListener);
      };
    }, []);

    const createButton = () => {
      const button = document.createElement('button');
      button.className = 'px-2 py-1 bg-gray-100 text-black dark:text-black dark:bg-gray-200 border border-gray-200 dark:border-gray-800 rounded-md shadow-md hover:bg-gray-200 dark:hover:bg-gray-100 focus:outline-none';

      const iconContainer = document.createElement('div');
      iconContainer.className = 'h-5 w-5';

      const root = ReactDOM.createRoot(iconContainer);
      root.render(<ArrowUturnDownIcon />);

      button.appendChild(iconContainer);
      // Stop propagation for mousedown and mouseup to avoid affecting other event listeners
      button.addEventListener('mousedown', event => event.stopPropagation());
      button.addEventListener('mouseup', event => event.stopPropagation());
      button.addEventListener('click', handleQuoteSelectedText);
      return button;
    };

    const handleQuoteSelectedText = () => {
      const selection = window.getSelection();
      if (selection) {
        const selectedText = selection.toString();
        const modifiedText = `Assistant wrote:\n${SNIPPET_MARKERS.begin}\n${selectedText}\n${SNIPPET_MARKERS.end}\n`;
        messageBoxRef.current?.pasteText(modifiedText);
        messageBoxRef.current?.focusTextarea();
      }
    };

    const handleAttachment = (event: React.MouseEvent<HTMLButtonElement>) => {
      event.preventDefault();
      event.stopPropagation();

      // Create an input element of type file
      const fileInput = document.createElement('input');
      fileInput.setAttribute('type', 'file');
      fileInput.setAttribute('multiple', '');
      const acceptedMimeTypes = ((allowImageAttachment !== 'no') ? IMAGE_MIME_TYPES : []).concat(TEXT_MIME_TYPES).join(',');
      fileInput.setAttribute('accept', acceptedMimeTypes);
      fileInput.click();

      // Event listener for file selection
      fileInput.onchange = (e) => {
        const files = fileInput.files;
        if (files) {
          Array.from(files).forEach((file) => {
            // Check if the file is an image
            if (file.type.startsWith('image/')) {
              if (fileDataRef.length >= MAX_IMAGE_ATTACHMENTS_PER_MESSAGE) {
                return;
              }
              preprocessImage(file, (base64Data, processedFile) => {
                setFileDataRef((prev) => [...prev, {
                  id: 0,
                  fileData: {
                    data: base64Data,
                    type: processedFile.type,
                    source: 'filename',
                    filename: processedFile.name,
                  }
                }]);
                if (allowImageAttachment == 'warn') {
                  // todo: could warn user
                }
              });
            }
            // Else, if the file is a text file
            else if (file.type.startsWith('text/')) {
              const reader = new FileReader();

              reader.onloadend = () => {
                const textContent = reader.result as string;
                const formattedText = `File: ${file.name}:\n${SNIPPET_MARKERS.begin}\n${textContent}\n${SNIPPET_MARKERS.end}\n`;
                insertTextAtCursorPosition(formattedText);

                // Focus the textarea and place the cursor at the end of the text
                if (textAreaRef.current) {
                  const textArea = textAreaRef.current;
                  textArea.focus();

                  const newCursorPos = textArea.value.length;

                  // Use setTimeout to ensure the operation happens in the next tick after render reflow
                  setTimeout(() => {
                    textArea.selectionStart = newCursorPos;
                    textArea.selectionEnd = newCursorPos;
                    handleAutoResize();
                    textArea.scrollTop = textArea.scrollHeight;
                  }, 0);
                }
              };

              reader.onerror = (errorEvent) => {
                console.error("File reading error:", errorEvent.target?.error);
              };

              reader.readAsText(file);
            }
          });
        }
      };
    };
    const handleUserScroll = (isAtBottom: boolean) => {
      setAllowAutoScroll(isAtBottom);
      setShowScrollButton(!isAtBottom);
    };


    const handleRemoveFileData = (index: number, fileRef: FileDataRef) => {
      setFileDataRef(fileDataRef.filter((_, i) => i !== index));
    };

    const handleModelChange = (value: string | null) => {
      if (value === null) {
        setModel(null);
      } else {
        fetchModelById(value).then(setModel);
      }
    };
    const fetchModelById = async (modelId: string): Promise<OpenAIModel | null> => {
      try {
        const fetchedModel = await ChatService.getModelById(modelId);
        return fetchedModel;
      } catch (error) {
        console.error('Failed to fetch model:', error);
        if (error instanceof Error) {
          NotificationService.handleUnexpectedError(error, 'Failed to fetch model.');
        }
        return null;
      }
    };

    const handleMouseUp = (event: React.MouseEvent<HTMLDivElement>) => {
      const selection = window.getSelection();
      if (selection && selection.toString().trim() !== '') {
        const range = selection.getRangeAt(0);
        const rect = range.getBoundingClientRect();

        // Remove the existing button if it exists
        if (buttonRef.current && buttonRef.current.parentNode) {
          buttonRef.current.parentNode.removeChild(buttonRef.current);
        }

        const newButton = createButton();
        const buttonHeight = 30; // Approximate height of the button
        const buttonWidth = newButton.offsetWidth;

        const chatContainer = document.getElementById('chat-container1');
        if (chatContainer) {
          const containerRect = chatContainer.getBoundingClientRect();

          newButton.style.position = 'absolute';
          newButton.style.left = `${rect.left - containerRect.left + (rect.width / 2) - (buttonWidth / 2)}px`; // Center horizontally relative to container
          newButton.style.top = `${rect.top - containerRect.top - buttonHeight}px`; // Position above the selection relative to container
          newButton.style.display = 'inline-block';
          newButton.style.verticalAlign = 'middle';
          newButton.style.zIndex = '1000';

          chatContainer.appendChild(newButton);

          buttonRef.current = newButton;
        }
      }
    };

    

    return (
      <div className={`${className} overflow-hidden w-full h-full relative flex z-0 dark:bg-gray-900`}>
        <div className="flex flex-col items-stretch w-full h-full">
          <main
            className="relative h-full transition-width flex flex-col overflow-hidden items-stretch flex-1"
            onMouseUp={handleMouseUp}>
            <div
              style={{ position: "sticky" }}
              className="absolute bottom-0 left-0 w-full border-t md:border-t-0 dark:border-white/20 md:border-transparent md:dark:border-transparent bg-white dark:bg-gray-900 md:!bg-transparent pt-2 ">
              {gid ? (
                <div
                  className={`inline-block absolute top-0 left-0 z-50 ${true ? 'sidebar-collapsed-margin' : 'sidebar-expanded-margin'}`}>
                  <ChatSettingDropdownMenu chatSetting={chatSettings} />
                </div>
              ) : null
              }
              {!conversation && chatSettings ? (
                <CustomChatSplash className=" -translate-y-[10%] " chatSettings={chatSettings} />
              ) : null}
              <Chat chatBlocks={responses} onChatScroll={handleUserScroll} conversation={conversation}
                model={model?.id || DEFAULT_MODEL}
                onModelChange={handleModelChange} allowAutoScroll={allowAutoScroll} loading={loading} />
              <form onSubmit={handleQuerySubmit}
                className="stretch mx-2 flex flex-row gap-3 last:mb-2 md:mx-4 md:last:mb-6 lg:mx-auto md:max-w-2xl lg:max-w-3xl xl:max-w-4xl 2xl:max-w-5xl 3xl:max-w-6xl 4xl:max-w7xl chat-input">
                <div id="message-box-border"
                  style={{ borderRadius: "1rem" }}
                  className="relative flex flex-col h-full flex-1 w-full py-2 flex-grow md:py-3 bg-white dark:bg-gray-850
         dark:text-white dark:bg-gray-850 border border-black/10 dark:border-gray-900/50
         focus-within:border-black/30 dark:focus-within:border-gray-500/50"
                >
                  {/* FileDataPreview Full Width at the Top */}
                  {fileDataRef.length > 0 && (
                    <div className="w-full">
                      <FileDataPreview fileDataRef={fileDataRef} removeFileData={handleRemoveFileData}
                        allowImageAttachment={allowImageAttachment == 'yes'} />
                    </div>
                  )}
                  {/* Container for Textarea and Buttons */}
                  <div className="flex items-center w-full relative space-x-2">
                    {/* Attachment Button */}
                    <div className="flex items-center justify-start">
                      <label htmlFor="file-upload" className="flex items-center cursor-pointer">
                        <PaperClipIcon className="h-6 w-6 mr-6" />
                        {/* <span className="text-sm text-gray-600">Upload File</span> */}
                      </label>
                      <input
                         id="file-upload"
                        name="fileUpload" // Add a name attribute
                        type="file"
                        onChange={handleFileChange}
                        className="hidden"
                      />
                    </div>
                    {/* Grammarly extension container */}
                    <div className="flex items-center " style={{ flexShrink: 0, minWidth: 'fit-content' }}>
                      {/* Grammarly extension buttons will render here without overlapping */}
                    </div>

                    {/* Textarea */}
                    <textarea
                      id="sendMessageInput"
                      name="message"
                      tabIndex={0}
                      ref={textAreaRef}
                      rows={1}
                      className="flex-auto m-0 resize-none border-0 bg-transparent px-2 py-2 focus:ring-0 focus-visible:ring-0 outline-none shadow-none dark:bg-transparent"
                      placeholder={t('send-a-message')}
                      onKeyDown={checkForSpecialKey}
                      onChange={(e) => {
                        handleTextChange(e);  // Call your custom change handler
                        setQuery(e.target.value); // Update the query state
                      }}
                      onPaste={handlePaste}
                      style={{ minWidth: 0 }}
                      value={query
                      }
                    />

                    {/* Cancel/Submit Button */}
                    <div className="flex items-center justify-end">
                      {loading ? (
                        <Tooltip title={t('cancel-output')} side="top" sideOffset={0}>
                          <button
                            onClick={(e) => handleCancel(e)}
                            className="p-1">
                            <StopCircleIcon className="h-6 w-6" />
                          </button>
                        </Tooltip>
                      ) : (
                        <SubmitButton
                          disabled={isTextEmpty || loading}
                          loading={loading}
                        />
                      )}
                    </div>
                  </div>
                </div>
              </form>
            </div>
          </main>
        </div>
      </div>
    );
  });
export default NewPageInterface;